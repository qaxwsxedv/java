# day20

1. emp1 테이블에서 부서번호를 입력하면
	해당 부서 소속의 사원들의
		사원번호, 사원이름, 직급, 급여
	을 조회하는 기능
	
	제어하는 기능 추가
	
		1. 이름으로 조회
			--> 이름리스트 출력
			--> 이름 입력창 실행
			--> 입력받은 이름으로 데이터 조회
			
		2. 부서번호로 조회
			--> 부서번호 리스트 출력
			--> 부서번호 입력창 실행
			--> 부서번호 입력답아서 데이터 조회
			
		3. wooyoung 사원 입사정보 입력
			사원번호	: 서브질의
			사원이름	: wooyoung
			직급		: MANAGER
			상사번호	: SMITH 사원번호
			입사일		: 오늘날짜 (시간 제외)
			급여		: 500
			커미션		: -500
			부서번호	: SMITH의 부서번호
			메일		: wooyoung@githrd.com
				
		4. wooyoung 사원의 급여를 501로 수정하세요.
		
숙제 ]
	4번 기능을
		1. 이름을 입력하면 이름에 해당하는 사원들의
			사원번호, 사원이름, 급여, 입사일, 부서번호
			를 출력해주는 기능을 추가하고
			
		2. 출력된 사원의 사원번호와 급여를 입력해서
			사원의 급여를 수정해주는 기능을 구형하세요.
			
--------------------------------------------------------------------------------------

Set 계열
==>
	특징 ]
		1. 입력순서를 보장하지 않는다.
			==> 나름의 규칙을 가지고 내부적으로 정렬을 해서 보관한다.
			
		2. 중복데이터를 허용하지 않는다.
			==> 같은 데이터가 다시 저장되면 
				먼저 데이터는 지우고
				새로운 데이터를 입력한다.
				
		***
		Set 계열은 데이터의 위치를 개발자가 알수 없으므로
		데이터를 꺼내는 함수가 존재하지 않는다.
		따라서 기억된 데이터를 추출하려면
			Iterator 또는 List계열
		변환해서 순차적으로 꺼내서 사용해야 한다.
		
	종류 ]
		
		1. HashSet
			==> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션
				따라서 우리가 상상하는 정렬은 이루어 지지 않는다.
				
				정말 참고 ] 몰라도되요
					HashSet(int initialCapacity, float loadFactor)
						loadFactor : 해쉬코드값을 만드는 규칙에 사용할 상수값을
										사용자가 지정해서 해쉬테이블을 만들어서 사용한다.
										
		2. TreeSet
			==> 내부적으로 Tree Sort라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가진 컬렉션
			
				특징 ]
					우리가 상상하는 정렬 방식을 이용한다.
					
					***
					정렬가능한 객체들만 기억할 수 있다.
					
				생성자 ]
					
					TreeSet(Comparator comparator)
					==> 정렬방식을 지정해서 TreeSet을 만든다.
					
					TreeSet(SortedSet<E> s)
					==> TreeSet을 이용해서 다시 TreeSet을 만드는 방법
					
				참고 함수 ]
					
					subSet()
					==> 하나의 Set에 담긴 내용 중에서 특정 부분만 골라서 새로운 Set을 만드는 함수
					
					headSet(E toElement)
					==> 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다.
					
					tailSet(E fromElement)

					==> 지정한 부분부터 마지막까지 골라서 새로운 Set을 만든다.
					
-------------------------------------------------------------------------------------------------------------------
Map
==> 하나의 데이터를 그 데이터를 구분할 수 있는
	키값과 한쌍으로 만들어서 데이터를 기억하는 컬렉션
	따라서 사용할 경우에는 키값을 이용해서 데이터를 꺼낼 수 있도록 해놓았다.
	
	Map 계열은 많은 양의 데이터를 보관하는 용도 보다는
	데이터를 손쉽게 구분하여 사용할 목적으로 사용된다.
	
HashMap / Hashtable
==>
	Hashtable이 이전 버젼이고
	HashMap이 나중 버젼이다.
	따라서 HashMap 사용을 권장하고 있다.
	
	내부적으로 키값을 해쉬 테이블을 이용해서 정렬해서 보관한다.
	
	주요함수 ]
		put(Object key, Object value)
		==> 데이터 입력함수
		
		get(Object key)
		==> 데이터 꺼내는 함수
		
	참고함수 ]
		valuse()
		==> 데이터들만 꺼내는 함수
		
			예 ]
				HachMap map = ...;
				
				Collection col = map.values();
				
				1.
					Iterator itor = col.iterator();
					
				2.
					ArryaList list = new ArrayList(col);
		
		keys() / keySet()
		==> 키값들만 꺼내주는 함수
		
			Enumeration<K> keys()
			참고 ]
				Enumeration : Iterator의 구버젼
								데이터를 순차적으로 꺼내서 사용해야 한다.
								
			Set<K> keySet()
			==> 키값들만 추출해서 Set으로 반환해주는 함수
			
		참고 ]
			HashMap에는 키값만 추출하는 함수가 keySet() 만 있다.
			
		참고 ]
			entrySet()
			==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
				(위의 함수를 사용하면 다른 방법으로도 꺼낼 수 있긴 하다.)
				==> 키값과 데이터를 VO(Map.Entry)에 담아서 Set으로 묶어주는 함수
				
					Set<Map.Entry>  <======== Set<VO>	VO : key, value 변수와 getters & setters 함수만 가지고 있다.
					
					HashMap nap = new HashMap();
					
					map.put("one", 1);
					map.put("two", 2);
					map.put("three", 3);
					
					
					Map.Entry
					<===
					VO {
						private Object key;
						private Object value;
						...
					}
					
					
			<===
				Map은 항상 키와 벨류가 있어야 저장된다.
				Set은 오직 한개만 저장할 수 있다.
				따라서 키와 벨류를 하나로 묶어야만 Set에 기억시킬 수 있을 것이다.
				
				이것을 해결하기 위해서 만들어진 VO클래스가 Map.Entry 클래스 이다.
				이 클래스는 내부에 key와 value라는 변수를 은닉화 시켜서 가지고 있는 클래스이다.
				데이터를 입력하는 함수와 채우는 함수도 만들어 놓았다.
				
				
TreeMap
==> TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map이다.
	이때 정렬기준은 키값을 이용해서 정렬하게 된다.
	<=== 따라서 키값이 크기비교가 가능한 데이터여야만 입력된다.
	
	필요하면 정렬기준을 정해서 사용할 수 있다.
참고 ]
	컬렉션안에는 다시 컬렉션이 입력될 수 있다.
	왜? 컬렉션 안에는 모든 클래스를 입력할 수 있으므로
	컬렉션도 클래스에 해당하므로 저장할 수 있다.
		
	